## defineModel() {#definemodel}

- Доступно только в 3.4+

Этот макрос позволяет объявить двустороннее связывание для входного параметра, который может быть использовано внутри `v-model` из родительского компонента. Пример использования также рассматривает в руководстве [`v-model` на компоненте](/guide/components/v-model).

Под капотом этот макрос объявляет модель входного параметра и соответствующее событие для обновления значения. Если первый аргумент это литерат строки, то он будет являться название входного параметра; иначе имя входного параметра будет по умолчанию `"modelValue"`. В обоих случаях вы можете передать дополнительный объект, который может содержать дополнительные опции для входного параметра и параметры преобразования значения модели.

```js
// объявляет входной параметр "modelValue", который потребляется родителем через v-model
const model = defineModel()
// ИЛИ: объявляет входной параметр "modelValue" с дополнительными опциями
const model = defineModel({ type: String })

// генерирует пользовательское событие "update:modelValue", когда меняется значение
model.value = 'hello'

// объявляет входной параметр "count", который потребляется родителем через v-model:count
const count = defineModel('count')
// ИЛИ: объявляет входной параметр "count" с дополнительными настройками
const count = defineModel('count', { type: Number, default: 0 })

function inc() {
  // генерирует пользовательское событие "update:count", когда меняется значение
  count.value++
}
```

:::warning Предупреждение
Если у вас есть значение `default` для свойства `defineModel`, и вы не предоставляете никакого значения для этого свойства из родительского компонента, это может привести к рассинхронизации между родительским и дочерним компонентами. В приведенном ниже примере родительский `myRef` не определен, а дочерний `model` равен 1:

```js
// дочерний компонент:
const model = defineModel({ default: 1 })

// родительский компонент:
const myRef = ref()
```

```html
<Child v-model="myRef"></Child>
```
:::

### Модификаторы и дескрипторы get/set {#modifiers-and-transformers}

Чтобы получить доступ к модификатором `v-model` директивы, мы можем деструктурировать возвращамое значение `defineModel()` вот так:

```js
const [modelValue, modelModifiers] = defineModel()

// все равно что v-model.trim
if (modelModifiers.trim) {
  // ...
}
```

Когда есть модификатор, нам, скорее всего, потребуется преобразовать значение при чтении или синхронизации с родителем. Для этого мы можем использовать дескрипторы `get` и `set`:

```js
const [modelValue, modelModifiers] = defineModel({
  // get() опущен, так как он здесь не нужен
  set(value) {
    // если используется модификатор .trim, возвращает изменённое значение
    if (modelModifiers.trim) {
      return value.trim()
    }
    // в противном случае возвращаем значение как есть
    return value
  }
})
```

### Использование вместе с TypeScript <sup class="vt-badge ts" /> {#usage-with-typescript}

Как `defineProps` и `defineEmits`, `defineModel` также может принимать типы аргументов, чтобы определить типы значения модели и модификаторов:

```ts
const modelValue = defineModel<string>()
//    ^? Ref<string | undefined>

// Значение по умолчанию с опцией, которая удаляет возможные undefined значения
const modelValue = defineModel<string>({ required: true })
//    ^? Ref<string>

const [modelValue, modifiers] = defineModel<string, 'trim' | 'uppercase'>()
//                 ^? Record<'trim' | 'uppercase', true | undefined>
```

## defineExpose() {#defineexpose}

Компоненты, использующие `<script setup>`, **по умолчанию закрытые** - т.е. публичный экземпляр компонента, получаемый через ссылку в шаблоне или цепочки `$parent`, **не** даёт доступа к каким-либо привязкам внутри `<script setup>`.

Для явного объявления свойств в компоненте `<script setup>` используйте макрос компилятора `defineExpose`:

```vue
<script setup>
import { ref } from 'vue'

const a = 1
const b = ref(2)

defineExpose({
  a,
  b
})
</script>
```

Когда родитель получает экземпляр этого компонента через ref в шаблоне, полученный экземпляр будет иметь вид `{ a: number, b: number }` (ref автоматически разворачиваются, как и для обычных экземпляров).

## defineOptions() {#defineoptions}

- Поддерживается только в 3.3+

Этот макрос может быть использован для объявления опций компонента прямо внутри `<script setup>` без создания отдельного `<script>` тега:

```vue
<script setup>
defineOptions({
  inheritAttrs: false,
  customOptions: {
    /* ... */
  }
})
</script>
```

- Это макрос. Опции будут подняты в область видимости модуля и не смогут обращаться к локальным переменным внутри `<script setup>`, которые не являются литеральными константами.

## defineSlots()<sup class="vt-badge ts"/> {#defineslots}

- Поддерживается только в версиях 3.3+.

Это макрос может быть использован для создания подсказок типов в IDE для имен слотов и проверки типов входных параметров.

`defineSlots()` принимает аргументом только тип и никаких рантайм-значений. Параметр типа должен быть литералом типа, где ключ свойства - это имя слота, а тип значения - функция слота. Первый аргумент функции - это входной параметр, который слот ожидает получить, и его тип будет использоваться для входных параметров слота в шаблоне. Возвращаемый тип пока что игнорируется и может быть `any`, но в будущем мы можем использовать его для проверки содержимого слота.

Этот макрос также возвращает объект `slots`, что эквивалентно объекту `slots`, который выставляется в контексте setup или возвращаемому функцией `useSlots()`.

```vue
<script setup lang="ts">
const slots = defineSlots<{
  default(props: { msg: string }): any
}>()
</script>
```
## `useSlots()` и `useAttrs()` {#useslots-useattrs}

Использование `slots` и `attrs` внутри `<script setup>` должно встречаться крайне редко, поскольку в шаблоне прямой доступ к ним можно получить через `$slots` и `$attrs`. В редких случаях, когда они всё же нужны, используйте вспомогательные методы `useSlots` и `useAttrs` соответственно:

```vue
<script setup>
import { useSlots, useAttrs } from 'vue'

const slots = useSlots()
const attrs = useAttrs()
</script>
```

`useSlots` и `useAttrs` - это рантайм-функции, которые возвращают эквивалент `setupContext.slots` и `setupContext.attrs`. Они могут использоваться и в обычных функциях Composition API.

## Использование вместе с обычной секцией `<script>` {#usage-alongside-normal-script}

`<script setup>` может использоваться вместе с обычной секцией `<script>`. Обычный `<script>` может понадобиться в случаях, когда необходимо:

- Объявление опций, которые не могут быть выражены в `<script setup>`, например, `inheritAttrs` или пользовательские опции, добавляемые плагинами.
- Объявление именованных экспортов.
- Запуск side-эффектов или создание объектов, которые должны выполняться только один раз.

```vue
<script>
// обычный <script>, выполняется в области видимости модуля (только один раз)
runSideEffectOnce()

// объявление дополнительных опций
export default {
  inheritAttrs: false,
  customOptions: {}
}
</script>

<script setup>
// выполняется в области видимости setup() (для каждого экземпляра)
</script>
```

Поддержка для совмещения `<script setup>` и `<script>` в одном компоненте ограничена в сценариях, описанных ниже. В частности: 

- **Не используйте** отдельный `<script>` тег для опций, который уже объявлены при помощи `<script setup>`, такие как `props` и `emits`.
- Переменные, созданные внутри `<script setup>`, не добавляются как свойства инстанса компонента, делая их невозможными к получению из Options API. Смешивать API таким образом категорически не рекомендуется.

Если вы оказались в одном из сценариев, которые не поддерживаются, то вам следует рассмотреть возможность перехода на явную функцию [`setup()`](/api/composition-api-setup) вместо использования `<script setup>`.

## Верхнеуровневый `await` {#top-level-await}

`await` верхнего уровня может быть использован внутри `<script setup>`. Полученный код будет скомпилирован как `async setup()`:

```vue
<script setup>
const post = await fetch(`/api/post/1`).then((r) => r.json())
</script>
```

Кроме того, ожидаемое выражение будет автоматически скомпилировано в формат, сохраняющий контекст текущего экземпляра компонента после `await`.

:::warning Примечание
`async setup()` должен использоваться в сочетании с [`Suspense`](/guide/built-ins/suspense.html), который в настоящее время является экспериментальной функцией. Мы планируем доработать и задокументировать его в одном из будущих релизов - но если вам интересно, то вы можете посмотреть его [тесты](https://github.com/vuejs/core/blob/main/packages/runtime-core/__tests__/components/Suspense.spec.ts), чтобы увидеть, как он работает.
:::
