## Фича дня: MVC, MVVM и MVP в контексте фронтенд фреймворков/библиотек

### MVC (Model-View-Controller)

**Model-View-Controller** (MVC, «Модель-Представление-Контроллер», «Модель-Вид-Контроллер») — схема разделения данных приложения и управляющей логики на три отдельных компонента: модель, представление и контроллер — таким образом, что модификация каждого компонента может осуществляться независимо

1. Модель (Model) предоставляет данные и реагирует на команды контроллера, изменяя своё состояние
2. Представление (View) отвечает за отображение данных модели пользователю, реагируя на изменения модели
3. Контроллер (Controller) интерпретирует действия пользователя, оповещая модель о необходимости изменений
**Примеры использования:**
- **AngularJS (1.x):** Ранние версии AngularJS использовали паттерн MVC. Модель управляет данными, контроллеры обрабатывают логику и взаимодействуют с моделью, а представление отображает данные.

**Преимущества:**
- Чёткое разделение обязанностей.
- Упрощает тестирование и поддержку кода.

**Недостатки:**
- Может быть сложно организовать сложные приложения, особенно когда требуется много взаимодействий между компонентами.

### MVVM (Model-View-ViewModel)

**MVVM** — это архитектурный шаблон, который строится на основе MVC, но добавляет дополнительный компонент — ViewModel:

1. Модель (англ. Model) (так же, как в классической MVC) представляет собой логику работы с данными и описание фундаментальных данных, необходимых для работы приложения.

2. Представление (англ. View) — графический интерфейс (окна, списки, кнопки и т. п.). Выступает подписчиком на событие изменения значений свойств или команд, предоставляемых Моделью Представления. В случае, если в Модели Представления изменилось какое-либо свойство, то она оповещает всех подписчиков об этом, и Представление, в свою очередь, запрашивает обновлённое значение свойства из Модели Представления. В случае, если пользователь воздействует на какой-либо элемент интерфейса, Представление вызывает соответствующую команду, предоставленную Моделью Представления.

3. Модель Представления (англ. ViewModel) — с одной стороны, абстракция Представления, а с другой — обёртка данных из Модели, подлежащиx связыванию. То есть, она содержит Модель, преобразованную к Представлению, а также команды, которыми может пользоваться Представление, чтобы влиять на Модель.

**Примеры использования:**
- **Vue.js:** Использует концепцию MVVM. Компоненты Vue.js выступают в роли ViewModel, связывая модель данных и представление через реактивные свойства.

- **Knockout.js:** Прямо реализует паттерн MVVM с помощью привязок данных и наблюдателей.

**Преимущества:**
- Чёткое разделение данных, представления и логики.
- Упрощает двустороннюю привязку данных и управление состоянием интерфейса.

**Недостатки:**
- Может быть избыточным для простых приложений.
- Увеличивает количество слоёв между моделью и представлением.

### MVP (Model-View-Presenter)

**MVP** — шаблон проектирования пользовательского интерфейса, который был разработан для облегчения автоматического модульного тестирования и улучшения разделения ответственности в презентационной логике (отделения логики от отображения):

1. Модель (англ. Model) предоставляет данные для пользовательского интерфейса.
2. Представление (англ. View) реализует отображение данных (Модели) и маршрутизацию пользовательских команд или событий Presenterʼу.
3. Presenter управляет Моделью и Представлением. Например извлекает данные из Модели и форматирует их для отображения в Представлении.

**Примеры использования:**
- **GWT (Google Web Toolkit):** Использует паттерн MVP для управления логикой приложения и взаимодействия с моделью и представлением.

**Преимущества:**
- Чёткое разделение обязанностей.
- Позволяет легко тестировать логику приложения, отделяя её от пользовательского интерфейса.

**Недостатки:**
- Може сложнее в реализации и поддержке для сложных интерфейсов.
- Презентер может стать сложным, если не будет четкого разделения обязанностей.

### Заключение

- **MVC** подходит для простых приложений с ясным разделением логики и представления, но может стать сложным для масштабирования.
- **MVVM** отлично подходит для приложений, где требуется двусторонняя привязка данных и более сложное управление состоянием интерфейса.
- **MVP** обеспечивает чёткое разделение между логикой и пользовательским интерфейсом, что упрощает тестирование и поддержку, особенно в сложных интерфейсах.

Каждый из этих паттернов имеет свои сильные и слабые стороны, и выбор подходящего зависит от специфики проекта и требований к архитектуре приложения.

## Ключевые отличия MVC, MVVM и MVP

### MVC (Model-View-Controller)

- **Модель (Model):** Управляет данными и бизнес-логикой приложения.
- **Представление (View):** Отображает данные пользователю и обновляет интерфейс на основе изменений в модели.
- **Контроллер (Controller):** Обрабатывает пользовательский ввод, обновляет модель и обновляет представление.

**Отличия:**
- Контроллер активно взаимодействует и с моделью, и с представлением.
- Контроллер является связующим звеном между моделью и представлением.
- Контроллер может стать сложным при увеличении логики и взаимодействий.

### MVVM (Model-View-ViewModel)

- **Модель (Model):** Как и в других паттернах, управляет данными и бизнес-логикой.
- **Представление (View):** Отображает данные и обновляется в зависимости от изменений в ViewModel.
- **ViewModel (Модель представления):** Подготавливает данные из модели для представления и управляет состоянием интерфейса. Обрабатывает ввод и обновляет модель.

**Отличия:**
- ViewModel действует как посредник, управляя состоянием и поведением интерфейса.
- Двусторонняя привязка данных между View и ViewModel упрощает синхронизацию состояния интерфейса и данных.
- Подходит для сложных интерфейсов с множеством элементов управления и состояния.

### MVP (Model-View-Presenter)

- **Модель (Model):** Управляет данными и бизнес-логикой.
- **Представление (View):** Отображает данные и передаёт пользовательский ввод Presenter'у. Обычно представляет собой интерфейс.
- **Презентер (Presenter):** Управляет логикой приложения и взаимодействует с моделью и представлением. Обрабатывает пользовательский ввод, обновляет модель и обновляет представление.

**Отличия:**
- Презентер полностью управляет логикой и взаимодействием между моделью и представлением.
- View обычно не содержит логики и просто отображает данные, передаваемые Presenter'ом.
- Презентер может стать сложным, если он обрабатывает много логики.

### Сравнение и заключение

- **MVC**: Контроллер активно управляет и моделью, и представлением, что может усложнять масштабирование и поддержку при увеличении логики. Подходит для приложений с чётко разграниченными обязанностями.

- **MVVM**: ViewModel служит посредником между моделью и представлением, облегчая управление состоянием интерфейса и поддерживая двустороннюю привязку данных. Хорошо подходит для сложных и интерактивных интерфейсов.

- **MVP**: Презентер управляет логикой приложения и взаимодействием между моделью и представлением, упрощая тестирование и поддержку. Особенно полезен, когда View должна быть простой и не содержать логику.

Выбор между этими паттернами зависит от сложности приложения, требований к интерфейсу и предпочтений в архитектурном подходе.

