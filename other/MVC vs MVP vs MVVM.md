## Фича дня: MVC, MVVM и MVP в контексте фронтенд фреймворков/библиотек

### MVC (Model-View-Controller)

**Model-View-Controller** (MVC, «Модель-Представление-Контроллер», «Модель-Вид-Контроллер») — схема разделения данных приложения и управляющей логики на три отдельных компонента: модель, представление и контроллер — таким образом, что модификация каждого компонента может осуществляться независимо

1. Модель (Model) предоставляет данные и реагирует на команды контроллера, изменяя своё состояние
2. Представление (View) отвечает за отображение данных модели пользователю, реагируя на изменения модели
3. Контроллер (Controller) интерпретирует действия пользователя, оповещая модель о необходимости изменений
**Примеры использования:**
- **AngularJS (1.x):** Ранние версии AngularJS использовали паттерн MVC. Модель управляет данными, контроллеры обрабатывают логику и взаимодействуют с моделью, а представление отображает данные.

**Преимущества:**
- Чёткое разделение обязанностей.
- Упрощает тестирование и поддержку кода.

**Недостатки:**
- Может быть сложно организовать сложные приложения, особенно когда требуется много взаимодействий между компонентами.

### MVVM (Model-View-ViewModel)

**MVVM** — это архитектурный шаблон, который строится на основе MVC, но добавляет дополнительный компонент — ViewModel:

1. Модель (англ. Model) (так же, как в классической MVC) представляет собой логику работы с данными и описание фундаментальных данных, необходимых для работы приложения.

2. Представление (англ. View) — графический интерфейс (окна, списки, кнопки и т. п.). Выступает подписчиком на событие изменения значений свойств или команд, предоставляемых Моделью Представления. В случае, если в Модели Представления изменилось какое-либо свойство, то она оповещает всех подписчиков об этом, и Представление, в свою очередь, запрашивает обновлённое значение свойства из Модели Представления. В случае, если пользователь воздействует на какой-либо элемент интерфейса, Представление вызывает соответствующую команду, предоставленную Моделью Представления.

3. Модель Представления (англ. ViewModel) — с одной стороны, абстракция Представления, а с другой — обёртка данных из Модели, подлежащиx связыванию. То есть, она содержит Модель, преобразованную к Представлению, а также команды, которыми может пользоваться Представление, чтобы влиять на Модель.

**Примеры использования:**
- **Vue.js:** Использует концепцию MVVM. Компоненты Vue.js выступают в роли ViewModel, связывая модель данных и представление через реактивные свойства.

- **Knockout.js:** Прямо реализует паттерн MVVM с помощью привязок данных и наблюдателей.

**Преимущества:**
- Чёткое разделение данных, представления и логики.
- Упрощает двустороннюю привязку данных и управление состоянием интерфейса.

**Недостатки:**
- Может быть избыточным для простых приложений.
- Увеличивает количество слоёв между моделью и представлением.

Шаблон MVVM делится на три части:

---

#### Из вики 

### MVP (Model-View-Presenter)

**MVP** — шаблон проектирования пользовательского интерфейса, который был разработан для облегчения автоматического модульного тестирования и улучшения разделения ответственности в презентационной логике (отделения логики от отображения):

1. Модель (англ. Model) предоставляет данные для пользовательского интерфейса.
2. Представление (англ. View) реализует отображение данных (Модели) и маршрутизацию пользовательских команд или событий Presenterʼу.
3. Presenter управляет Моделью и Представлением. Например извлекает данные из Модели и форматирует их для отображения в Представлении.

**Примеры использования:**
- **GWT (Google Web Toolkit):** Использует паттерн MVP для управления логикой приложения и взаимодействия с моделью и представлением.

**Преимущества:**
- Чёткое разделение обязанностей.
- Позволяет легко тестировать логику приложения, отделяя её от пользовательского интерфейса.

**Недостатки:**
- Може сложнее в реализации и поддержке для сложных интерфейсов.
- Презентер может стать сложным, если не будет четкого разделения обязанностей.

### Заключение

- **MVC** подходит для простых приложений с ясным разделением логики и представления, но может стать сложным для масштабирования.
- **MVVM** отлично подходит для приложений, где требуется двусторонняя привязка данных и более сложное управление состоянием интерфейса.
- **MVP** обеспечивает чёткое разделение между логикой и пользовательским интерфейсом, что упрощает тестирование и поддержку, особенно в сложных интерфейсах.

Каждый из этих паттернов имеет свои сильные и слабые стороны, и выбор подходящего зависит от специфики проекта и требований к архитектуре приложения.
